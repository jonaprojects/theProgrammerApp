import { Questions } from "./models";
const clangQuestions: Questions = [
  {
    id: 1,
    question: "האם ניתן להשתמש בפקודת 'goto' בשפת C?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, שפת C תומכת בפקודת 'goto'. עם זאת, השימוש בה אינו מומלץ בדרך כלל מכיוון שהוא עלול להפוך את הקוד לפחות קריא ויותר מועד לשגיאות.",
  },
  {
    id: 2,
    question: "האם המשפט 'int x;' מאתחל את המשתנה x לערך 0?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, המשפט 'int x;' מצהיר על משתנה מסוג int אך אינו מאתחל אותו. ערכו של x יהיה לא מוגדר עד שיוקצה לו ערך באופן מפורש.",
  },
  {
    id: 3,
    question: "האם ניתן להגדיר פונקציות בתוך פונקציות אחרות בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, שפת C אינה תומכת בהגדרת פונקציות מקוננות (nested functions). כל הפונקציות חייבות להיות מוגדרות ברמה הגלובלית של התוכנית.",
  },
  {
    id: 4,
    question: "האם המילה השמורה 'static' משנה את משך החיים של משתנה מקומי?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, כאשר מגדירים משתנה מקומי כ-'static', משך החיים שלו הופך להיות לאורך כל זמן ריצת התוכנית, במקום רק במסגרת הבלוק שבו הוא הוגדר.",
  },
  {
    id: 5,
    question: "האם ניתן להשתמש במערכים דינמיים בשפת C?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, ניתן ליצור מערכים דינמיים בשפת C באמצעות הקצאת זיכרון דינמית עם פונקציות כמו malloc() או calloc(). עם זאת, C אינה מספקת מערכים דינמיים מובנים כמו בשפות אחרות.",
  },
  {
    id: 6,
    question: "האם המילה השמורה 'volatile' משמשת להגדרת קבועים?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, המילה השמורה 'volatile' משמשת להודיע למהדר שערכו של משתנה עשוי להשתנות בכל עת, ללא התערבות ישירה של הקוד. היא משמשת בעיקר עבור משתנים המייצגים חומרה או משתנים המשותפים עם קוד אסינכרוני.",
  },
  {
    id: 7,
    question: "האם ניתן להשתמש בהורשה בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, שפת C אינה תומכת בהורשה באופן ישיר כמו שפות מונחות עצמים. C היא שפה פרוצדורלית ואינה כוללת מנגנונים מובנים לתכנות מונחה עצמים כמו מחלקות והורשה.",
  },
  {
    id: 8,
    question: "האם הפקודה 'sizeof()' מחזירה את גודל המשתנה בבתים?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, הפקודה 'sizeof()' מחזירה את גודל המשתנה או הטיפוס בבתים. זוהי פקודה שימושית מאוד לקביעת גודל של טיפוסי נתונים או מבנים.",
  },
  {
    id: 9,
    question: "האם ניתן להשתמש במילה השמורה 'class' בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, המילה השמורה 'class' אינה קיימת בשפת C. היא שייכת לשפות מונחות עצמים כמו C++. בשפת C משתמשים במבנים (structs) כדי לקבץ נתונים יחד, אך ללא התכונות של מחלקות כמו בתכנות מונחה עצמים.",
  },
  {
    id: 10,
    question: "האם הפקודה 'break' יכולה לשמש ליציאה מלולאות מקוננות?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, הפקודה 'break' מסיימת רק את הלולאה הפנימית ביותר או את ה-switch הנוכחי. כדי לצאת מלולאות מקוננות מרובות, יש להשתמש בשיטות אחרות כמו משתני דגל או הפקודה 'goto' (למרות שהשימוש ב-'goto' אינו מומלץ בדרך כלל).",
  },
  {
    id: 11,
    question: "מהו הערך המוחזר על ידי הפונקציה main() בתוכנית C תקינה?",
    type: "multiple",
    correctAnswer: "0",
    incorrectAnswers: ["1", "-1", "NULL"],
    explanation:
      "בתוכנית C תקינה, הפונקציה main() מחזירה 0 כדי לציין סיום מוצלח. כל ערך אחר מציין שגיאה.",
  },
  {
    id: 12,
    question: "איזה אופרטור משמש להשגת כתובת של משתנה?",
    type: "multiple",
    correctAnswer: "&",
    incorrectAnswers: ["*", "#", "@"],
    explanation: "האופרטור & משמש להשגת הכתובת בזיכרון של משתנה בשפת C.",
  },
  {
    id: 13,
    question: "האם שפת C תומכת ב-function overloading?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, שפת C אינה תומכת ב-function overloading. זוהי תכונה של שפות מונחות עצמים כמו C++.",
  },
  {
    id: 14,
    question: "מהו הגודל של טיפוס int בשפת C?",
    type: "multiple",
    correctAnswer: "תלוי במערכת",
    incorrectAnswers: ["תמיד 4 בתים", "תמיד 2 בתים", "תמיד 8 בתים"],
    explanation:
      "הגודל של int בשפת C תלוי בארכיטקטורת המערכת ובמימוש הספציפי של המהדר.",
  },
  {
    id: 15,
    question: "האם ניתן להשתמש במשתנים מסוג unsigned float?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C אין טיפוס unsigned float. המילה השמורה unsigned משמשת רק עבור טיפוסים שלמים.",
  },
  {
    id: 16,
    question: "מהו התפקיד של הפקודה typedef בשפת C?",
    type: "multiple",
    correctAnswer: "יצירת כינוי לטיפוס קיים",
    incorrectAnswers: ["הגדרת משתנה חדש", "יצירת פונקציה", "הקצאת זיכרון"],
    explanation:
      "הפקודה typedef משמשת ליצירת כינוי או שם חלופי לטיפוס נתונים קיים בשפת C.",
  },
  {
    id: 17,
    question: "האם ניתן להשתמש בפקודת switch עם משתנים מסוג float?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C לא ניתן להשתמש בפקודת switch עם משתנים מסוג float. switch עובד רק עם טיפוסים שלמים ומנויים.",
  },
  {
    id: 18,
    question: "מהו התפקיד של המילה השמורה extern בשפת C?",
    type: "multiple",
    correctAnswer: "הצהרה על משתנה שהוגדר בקובץ אחר",
    incorrectAnswers: [
      "הגדרת משתנה גלובלי",
      "יצירת פונקציה חיצונית",
      "ייבוא ספריה",
    ],
    explanation:
      "המילה השמורה extern משמשת להצהרה על משתנה שהוגדר בקובץ מקור אחר, מאפשרת שימוש במשתנים גלובליים בין קבצים שונים.",
  },
  {
    id: 19,
    question: "האם המשפט 'int *p[10];' מגדיר מערך של מצביעים או מצביע למערך?",
    type: "multiple",
    correctAnswer: "מערך של מצביעים",
    incorrectAnswers: ["מצביע למערך", "מצביע למצביע", "מערך של מערכים"],
    explanation:
      "המשפט 'int *p[10];' מגדיר מערך בגודל 10 של מצביעים למשתנים מסוג int.",
  },
  {
    id: 20,
    question: "האם ניתן להשתמש בפקודת return מחוץ לפונקציה?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C לא ניתן להשתמש בפקודת return מחוץ לפונקציה. פקודת return משמשת אך ורק בתוך פונקציות.",
  },
  {
    id: 21,
    question: "מהו התפקיד של המילה השמורה 'union' בשפת C?",
    type: "multiple",
    correctAnswer:
      "הגדרת טיפוס שיכול להכיל משתנים מטיפוסים שונים באותו מיקום זיכרון",
    incorrectAnswers: [
      "יצירת מערך דינמי",
      "הגדרת פונקציה עם מספר משתנה של פרמטרים",
      "יצירת מחלקה בסיסית להורשה",
    ],
    explanation:
      "'union' מאפשר להגדיר טיפוס שיכול להכיל משתנים מטיפוסים שונים, אך רק אחד מהם יכול להיות בשימוש בכל רגע נתון, וכולם חולקים את אותו מיקום בזיכרון.",
  },
  {
    id: 22,
    question: "האם המשפט 'int i = 5, j = i++;' מציב את אותו ערך ל-i ול-j?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, לאחר ביצוע משפט זה, i יהיה שווה ל-6 ו-j יהיה שווה ל-5. האופרטור '++' לאחר המשתנה (postfix) מגדיל את ערך i רק לאחר שערכו הנוכחי (5) הוצב ב-j.",
  },
  {
    id: 23,
    question: "מהו התפקיד של הפקודה 'realloc()' בשפת C?",
    type: "multiple",
    correctAnswer: "שינוי גודל של בלוק זיכרון שהוקצה דינמית",
    incorrectAnswers: [
      "שחרור זיכרון שהוקצה דינמית",
      "הקצאת בלוק זיכרון חדש",
      "איפוס בלוק זיכרון קיים",
    ],
    explanation:
      "הפונקציה 'realloc()' משמשת לשינוי הגודל של בלוק זיכרון שכבר הוקצה דינמית, מאפשרת להגדיל או להקטין את הבלוק לפי הצורך.",
  },
  {
    id: 24,
    question:
      "האם המשפט 'char str[] = \"Hello\";' מקצה זיכרון עבור 5 או 6 תווים?",
    type: "multiple",
    correctAnswer: "6 תווים",
    incorrectAnswers: ["5 תווים", "7 תווים", "תלוי במהדר"],
    explanation:
      "המשפט מקצה זיכרון עבור 6 תווים. 5 תווים עבור המחרוזת \"Hello\" ותו נוסף עבור תו הסיום '\\0'.",
  },
  {
    id: 25,
    question: "האם ניתן להשתמש בפקודת 'continue' בתוך פקודת 'switch'?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C לא ניתן להשתמש בפקודת 'continue' בתוך 'switch'. הפקודה 'continue' משמשת רק בתוך לולאות.",
  },
  {
    id: 26,
    question: "מהו התפקיד של המילה השמורה 'register' בשפת C?",
    type: "multiple",
    correctAnswer: "בקשה מהמהדר לאחסן משתנה ברגיסטר של המעבד",
    incorrectAnswers: [
      "הגדרת משתנה גלובלי",
      "יצירת מצביע לפונקציה",
      "הגדרת קבוע",
    ],
    explanation:
      "המילה השמורה 'register' היא בקשה מהמהדר לאחסן את המשתנה ברגיסטר של המעבד לגישה מהירה יותר, אך המהדר יכול להתעלם מבקשה זו.",
  },
  {
    id: 27,
    question: "האם המשפט 'int x = 3 + 2;' מבוצע בזמן הקומפילציה או בזמן הריצה?",
    type: "multiple",
    correctAnswer: "בזמן הקומפילציה",
    incorrectAnswers: ["בזמן הריצה", "תלוי במהדר", "תלוי בהגדרות האופטימיזציה"],
    explanation:
      "המשפט 'int x = 3 + 2;' הוא ביטוי קבוע שיחושב בזמן הקומפילציה. המהדר יציב את הערך 5 ישירות במשתנה x.",
  },
  {
    id: 28,
    question: "האם ניתן להגדיר מערך בגודל משתנה בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C סטנדרטית לא ניתן להגדיר מערך בגודל משתנה. גודל המערך חייב להיות קבוע בזמן הקומפילציה. עם זאת, ניתן להשתמש בהקצאה דינמית ליצירת מערך בגודל משתנה בזמן ריצה.",
  },
  {
    id: 29,
    question: "מהו התפקיד של הפקודה 'memcpy()' בשפת C?",
    type: "multiple",
    correctAnswer: "העתקת בלוק זיכרון ממיקום אחד לאחר",
    incorrectAnswers: [
      "השוואת שני בלוקי זיכרון",
      "מציאת תו במחרוזת",
      "הקצאת בלוק זיכרון חדש",
    ],
    explanation:
      "הפונקציה 'memcpy()' משמשת להעתקת בלוק זיכרון מכתובת מקור לכתובת יעד. היא מעתיקה מספר מוגדר של בתים ללא התחשבות בתוכן הזיכרון.",
  },
  {
    id: 30,
    question: "האם המשפט 'void *ptr;' מגדיר מצביע לפונקציה או מצביע כללי?",
    type: "multiple",
    correctAnswer: "מצביע כללי",
    incorrectAnswers: ["מצביע לפונקציה", "מצביע לריק", "שגיאת קומפילציה"],
    explanation:
      "המשפט 'void *ptr;' מגדיר מצביע כללי, כלומר מצביע שיכול להצביע לכל טיפוס נתונים. זה שונה ממצביע לפונקציה, שיש לו תחביר שונה.",
  },

  {
    id: 31,
    question: "מהו התפקיד של המאקרו NULL בשפת C?",
    type: "multiple",
    correctAnswer: "ייצוג מצביע לא חוקי או ריק",
    incorrectAnswers: ["איפוס משתנה", "סיום מחרוזת", "הגדרת קבוע שלילי"],
    explanation:
      "המאקרו NULL משמש לייצוג מצביע לא חוקי או ריק בשפת C. זה בדרך כלל מוגדר כ-0 או כ-((void*)0).",
  },
  {
    id: 32,
    question: "האם ניתן להשתמש בפקודת sizeof על פונקציה?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C לא ניתן להשתמש בפקודת sizeof על פונקציה. sizeof פועל על טיפוסי נתונים ומשתנים, אך לא על פונקציות.",
  },
  {
    id: 33,
    question: "מהו התפקיד של המילה השמורה 'restrict' בשפת C?",
    type: "multiple",
    correctAnswer: "אופטימיזציה למצביעים",
    incorrectAnswers: ["הגבלת גישה למשתנה", "יצירת קבוע", "הגדרת משתנה מקומי"],
    explanation:
      "המילה השמורה 'restrict' היא רמז למהדר שמצביע מסוים הוא הדרך היחידה לגשת לאובייקט שאליו הוא מצביע, מה שמאפשר אופטימיזציות מסוימות.",
  },
  {
    id: 34,
    question: "האם המשפט 'int a[5] = {1, 2};' חוקי בשפת C?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, המשפט חוקי. הוא מאתחל את שני האיברים הראשונים של המערך ל-1 ו-2, ואת שאר האיברים ל-0 באופן אוטומטי.",
  },
  {
    id: 35,
    question: "מהו התפקיד של הפקודה 'fflush()' בשפת C?",
    type: "multiple",
    correctAnswer: "ריקון מאגר קלט/פלט",
    incorrectAnswers: ["סגירת קובץ", "מחיקת תוכן קובץ", "קריאת שורה מקובץ"],
    explanation:
      "הפונקציה 'fflush()' משמשת לריקון מאגר הקלט/פלט, מה שמבטיח שכל הנתונים שנכתבו לזרם (כמו קובץ או מסוף) אכן נשלחו ליעדם.",
  },
  {
    id: 36,
    question: "האם ניתן להשתמש במשתנה כגודל מערך בהצהרה סטטית?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בהצהרה סטטית של מערך בשפת C, גודל המערך חייב להיות קבוע ידוע בזמן הקומפילציה. לא ניתן להשתמש במשתנה לקביעת גודל המערך בהצהרה סטטית.",
  },
  {
    id: 37,
    question: "מהו התפקיד של המילה השמורה 'auto' בשפת C?",
    type: "multiple",
    correctAnswer: "הצהרה על משתנה מקומי (ברירת מחדל)",
    incorrectAnswers: [
      "הקצאת זיכרון אוטומטית",
      "יצירת משתנה גלובלי",
      "הגדרת טיפוס נתונים דינמי",
    ],
    explanation:
      "המילה השמורה 'auto' בשפת C מצהירה על משתנה מקומי, אך היא נחשבת מיותרת כי זו ברירת המחדל למשתנים מקומיים. בC++11 ומעלה יש לה משמעות אחרת.",
  },
  {
    id: 38,
    question: "האם הביטוי '5['abcdef']' הוא חוקי וזהה ל-'abcdef[5]' בשפת C?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, הביטוי '5['abcdef']' הוא חוקי ושקול ל-'abcdef[5]'. בשפת C, a[b] מתורגם ל-*(a + b), ולכן הסדר ניתן להחלפה. עם זאת, הצורה הראשונה אינה מקובלת ועלולה לבלבל.",
  },
  {
    id: 39,
    question: "מהו התפקיד של המילה השמורה 'inline' בשפת C?",
    type: "multiple",
    correctAnswer: "בקשה מהמהדר להחליף קריאה לפונקציה בגוף הפונקציה עצמה",
    incorrectAnswers: [
      "הגדרת פונקציה בשורה אחת",
      "יצירת פונקציה פנימית",
      "הגדרת משתנה זמני",
    ],
    explanation:
      "המילה השמורה 'inline' היא בקשה מהמהדר להחליף את הקריאה לפונקציה בגוף הפונקציה עצמה, במטרה לשפר את ביצועי התוכנית. זוהי רק בקשה, והמהדר יכול להתעלם ממנה.",
  },
  {
    id: 40,
    question: "האם ניתן להגדיר מערך בגודל אפס בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C סטנדרטית לא ניתן להגדיר מערך בגודל אפס. גודל המערך חייב להיות חיובי. עם זאת, חלק מהמהדרים מאפשרים זאת כהרחבה לא סטנדרטית.",
  },
  {
    id: 41,
    question: "מהו התפקיד של המילה השמורה 'volatile' בשפת C?",
    type: "multiple",
    correctAnswer: "הוראה למהדר לא לבצע אופטימיזציות על המשתנה",
    incorrectAnswers: [
      "הגדרת משתנה זמני",
      "יצירת משתנה גלובלי",
      "הגדרת קבוע שניתן לשנות",
    ],
    explanation:
      "'volatile' מורה למהדר שערך המשתנה עשוי להשתנות בכל עת, ללא התערבות ישירה של הקוד, ולכן אין לבצע אופטימיזציות על גישות אליו.",
  },
  {
    id: 42,
    question: "האם המשפט 'int *p = &(int){5};' הוא חוקי בשפת C?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, משפט זה חוקי ב-C99 ומעלה. זוהי יצירה של מצביע למשתנה אנונימי זמני. עם זאת, יש להיזהר משימוש בו מחוץ לביטוי המיידי.",
  },
  {
    id: 43,
    question: "מהו התפקיד של הפונקציה 'longjmp()' בשפת C?",
    type: "multiple",
    correctAnswer: "קפיצה לא מקומית לנקודה שנשמרה קודם לכן",
    incorrectAnswers: [
      "ביצוע קפיצה לכתובת רחוקה בזיכרון",
      "יצירת תהליך חדש",
      "הקצאת בלוק זיכרון גדול",
    ],
    explanation:
      "הפונקציה 'longjmp()' מבצעת קפיצה לא מקומית לנקודה בתוכנית שנשמרה קודם לכן באמצעות 'setjmp()'. היא משמשת למימוש מנגנוני טיפול בחריגות.",
  },
  {
    id: 44,
    question: "האם ניתן להשתמש במילה השמורה 'const' עם מצביע לפונקציה?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, ניתן להשתמש ב-'const' עם מצביע לפונקציה. למשל, 'int (*const p)(int) = &func;' מגדיר מצביע קבוע לפונקציה שמקבלת int ומחזירה int.",
  },
  {
    id: 45,
    question: "מהו התפקיד של המאקרו '__func__' בשפת C?",
    type: "multiple",
    correctAnswer: "מחרוזת המכילה את שם הפונקציה הנוכחית",
    incorrectAnswers: [
      "הפעלת פונקציה",
      "בדיקה אם משתנה הוא פונקציה",
      "יצירת פונקציה אנונימית",
    ],
    explanation:
      "המאקרו '__func__' הוא מאקרו מובנה המכיל מחרוזת עם שם הפונקציה הנוכחית. הוא שימושי לצורכי דיבוג ורישום.",
  },
  {
    id: 46,
    question: "האם ניתן להגדיר מבנה (struct) ריק בשפת C?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C סטנדרטית לא ניתן להגדיר מבנה ריק לחלוטין. מבנה חייב להכיל לפחות חבר אחד. עם זאת, חלק מהמהדרים מאפשרים זאת כהרחבה לא סטנדרטית.",
  },
  {
    id: 47,
    question: "מהו התפקיד של המילה השמורה '_Alignas' בשפת C?",
    type: "multiple",
    correctAnswer: "הגדרת יישור בזיכרון למשתנה או טיפוס",
    incorrectAnswers: [
      "הגדרת משתנה כמוסתר",
      "יצירת כינוי לטיפוס",
      "הגדרת קבוע קומפילציה",
    ],
    explanation:
      "המילה השמורה '_Alignas', שהוצגה ב-C11, מאפשרת לקבוע את היישור בזיכרון של משתנה או טיפוס, מה שיכול להשפיע על הביצועים ועל התאימות עם חומרה מסוימת.",
  },
  {
    id: 48,
    question: "האם הביטוי 'sizeof(char)' תמיד שווה ל-1?",
    type: "yesno",
    correctAnswer: true,
    explanation:
      "כן, לפי תקן השפה, 'sizeof(char)' תמיד שווה ל-1, ללא קשר לארכיטקטורת המערכת או למימוש הספציפי של המהדר.",
  },
  {
    id: 49,
    question: "מהו התפקיד של המאקרו 'offsetof' בשפת C?",
    type: "multiple",
    correctAnswer: "חישוב ההיסט של חבר במבנה",
    incorrectAnswers: [
      "בדיקת גודל של טיפוס",
      "חישוב מספר החברים במבנה",
      "המרת כתובת לאינדקס מערך",
    ],
    explanation:
      "המאקרו 'offsetof' מחשב את ההיסט בבתים של חבר מסוים בתוך מבנה. הוא שימושי במצבים שבהם נדרשת גישה ישירה לחברי מבנה באמצעות היסטים.",
  },
  {
    id: 50,
    question: "האם ניתן להשתמש במילה השמורה 'auto' בפרמטרים של פונקציה?",
    type: "yesno",
    correctAnswer: false,
    explanation:
      "לא, בשפת C לא ניתן להשתמש במילה השמורה 'auto' בהצהרת פרמטרים של פונקציה. 'auto' משמש רק למשתנים מקומיים בתוך גוף הפונקציה.",
  },
];

export default clangQuestions;
